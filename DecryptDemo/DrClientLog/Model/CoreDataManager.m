//
//  CoreDataManager.m
//  DrClientLog
//
//  Created by Ge on 2019/5/8.
//  Copyright © 2019 Ge. All rights reserved.
//

#import "CoreDataManager.h"
#import "Logger.h"

#define SQLLITE_PREFIX @"CoreDataXML-"
#define SQLLITE_SUFFIX @".db"
#define CoreDataFileName @"DrLogWS"
#define MODEL_NAMES @"Pref", nil
#define CORE_MANAGER_CONTEXT @"CoreDataManagedObjectContext"

@interface CoreDataManager()

@property (strong, nonatomic) NSManagedObjectModel *managedObjectModel;
@property (strong, nonatomic) NSManagedObjectContext *managedObjectContext;
@property (strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;

@end

@implementation CoreDataManager

+ (instancetype)defaultManager {
    static CoreDataManager *sharedManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedManager = [[CoreDataManager alloc] init];
    });
    return sharedManager;
}

- (NSManagedObjectModel *)managedObjectModel {
    // override the autogenerated method -- see http://iphonedevelopment.blogspot.com/2009/09/core-data-migration-problems.html
    NSMutableArray *models = [NSMutableArray array];
    NSArray *allModels = [NSArray arrayWithObjects:MODEL_NAMES];
    for (NSString *modelName in allModels) {
        NSString *path = [[NSBundle mainBundle] pathForResource:modelName ofType:@"momd"];
        if (path == nil) {
            NSLog(@"could not find model: %@", modelName);
        } else {
            NSManagedObjectModel *aModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:[NSURL fileURLWithPath:path]];
            [models addObject:aModel];
        }
    }
    _managedObjectModel = [NSManagedObjectModel modelByMergingModels:models];
    return _managedObjectModel;
}

- (NSManagedObjectContext *)managedObjectContext {
    // 每个线程用自己的context
    NSMutableDictionary *threadDict = [[NSThread currentThread] threadDictionary];
    NSManagedObjectContext *localContext = [threadDict objectForKey:CORE_MANAGER_CONTEXT];
    if (localContext) {
        return localContext;
    }
    
    NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
    if (coordinator != nil) {
        localContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
        [localContext setPersistentStoreCoordinator: coordinator];
        [threadDict setObject:localContext forKey:CORE_MANAGER_CONTEXT];
        
        if ([[NSThread currentThread] isMainThread]) {
            // 主线程创建
        } else {
            // 子线程需要通知主线程更新
            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(mergeContextChangesForNotification:) name:NSManagedObjectContextDidSaveNotification object:localContext];
        }
    }
    return localContext;
}

- (NSPersistentStoreCoordinator *)persistentStoreCoordinator {
    if (_persistentStoreCoordinator != nil) {
        return _persistentStoreCoordinator;
    }
    
    NSString *storePath = [self storeFileName];
    NSURL *storeURL = [NSURL fileURLWithPath:storePath];
    
    NSError *error = nil;
    _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel: [self managedObjectModel]];
    
    //    NSDictionary *options = nil;
    NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:
                             [NSNumber numberWithBool:YES], NSMigratePersistentStoresAutomaticallyOption,
                             [NSNumber numberWithBool:NO], NSInferMappingModelAutomaticallyOption, /*不需要coredata自动数据迁移*/
                             /*storeVersion, NSStoreModelVersionIdentifiersKey,*/
                             nil];
    
    if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:options error:&error])  {
        [Logger error:@"CoreDataManager failed to create or access the persistent store: %@", [error userInfo]];
        
        // see if we failed because of changes to the db
        if (![[self storeFileName] isEqualToString:[self currentStoreFileName]]) {
            [Logger error:@"This app has been upgraded since last use of Core Data. If it crashes on launch, reinstalling should fix it."];
            if ([self migrateData]) {
                // storeFileName has changed
                storeURL = [NSURL fileURLWithPath:[self storeFileName]];
            } else {
                [Logger error:@"Data migration failed! Wiping out core data."];
                [self wipeData];
                storeURL = [NSURL fileURLWithPath:[self currentStoreFileName]];
            }
            
            [Logger error:@"Attempting to recreate the persistent store..."];
            if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType
                                                           configuration:nil URL:storeURL options:options error:&error]) {
                [Logger error:@"Failed to recreate the persistent store: %@", [error userInfo]];
            }
        }
        // putting this here for faster debugging.
        // TODO: in production the user should be the one initiating this.
        else {
            [Logger error:@"Nothing to migrate! Wiping out core data."];
            [self wipeData];
            _persistentStoreCoordinator = nil;
            _managedObjectModel = nil;
        }
    }
    return _persistentStoreCoordinator;
}

#pragma mark -
- (NSString *)storeFileName {
    NSString *currentFileName = [self currentStoreFileName];

    if (![[NSFileManager defaultManager] fileExistsAtPath:currentFileName]) {
        NSString *newsVersionString = @"";
        NSArray *files = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:[self getApplicationSupportPath] error:NULL];
        // find all files like CoreDataXML.* and pick the latest one
        for (NSString *file in files) {
            NSMutableString *filePrefix = [NSMutableString string];
            [filePrefix appendString:SQLLITE_PREFIX];
            [filePrefix appendFormat:@"%@.", CoreDataFileName, nil];
            if ([file hasPrefix:filePrefix] && [file hasSuffix:SQLLITE_SUFFIX]) {
                // 找已经存在的版本
                NSArray *array = [file componentsSeparatedByString:@"."];
                // 从文件名获取版本号
                NSMutableString *versionString = [NSMutableString string];
                for(int i = 1; i < array.count - 1; i++) {
                    [versionString appendString:[array objectAtIndex:i]];
                }
                // 选择最近的版本
                if(NSOrderedDescending == [versionString compare:newsVersionString]) {
                    newsVersionString = versionString;
                    currentFileName = [[self getApplicationSupportPath] stringByAppendingPathComponent:file];
                }
            }
        }
    }
    [Logger debug:@"Core Data stored at %@", currentFileName];
    return currentFileName;
}

- (NSString *)currentStoreFileName {
    NSMutableString *storeFileName = [NSMutableString string];
    [storeFileName appendString:SQLLITE_PREFIX];
    [storeFileName appendFormat:@"%@.", CoreDataFileName, nil];
    
    NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];
    [storeFileName appendFormat:@"%@%@", version, SQLLITE_SUFFIX];
    [Logger debug:@"CurrentStoreFileName: %@", storeFileName];
    return [[self getApplicationSupportPath] stringByAppendingPathComponent:storeFileName];
}

- (NSString *)getApplicationSupportPath {
    //用bundleid作为路径
    NSString *bundleId = [@"/" stringByAppendingString:[[NSBundle mainBundle] bundleIdentifier]];
    NSString *supportPath = [NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES).firstObject stringByAppendingFormat:@"/%@", bundleId];
    BOOL isDir = NO;
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:supportPath isDirectory:&isDir]) {
        //文件不存在
        [self createDir:supportPath];
    } else if (isDir == NO) {
        //文件存在，不是目录
        [[NSFileManager defaultManager] removeItemAtPath:supportPath error:nil];
        [self createDir:supportPath];
    }
    return supportPath;
}

- (void)createDir:(NSString *)supportPath {
    if (![[NSFileManager defaultManager] createDirectoryAtPath:supportPath withIntermediateDirectories:YES attributes:nil error:nil]) {
        [Logger error:@"Create dir failed: %@", supportPath];
    }
}

#pragma mark -
- (BOOL)migrateData{
    NSError *error = nil;
    
    NSString *sourcePath = [self storeFileName];
    NSURL *sourceURL = [NSURL fileURLWithPath:sourcePath];
    NSURL *destURL = [NSURL fileURLWithPath: [self currentStoreFileName]];
    
    [Logger debug:@"Attempting to migrate from %@ to %@", [[self storeFileName] lastPathComponent], [[self currentStoreFileName] lastPathComponent]];
    
    
    NSDictionary *sourceMetadata = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType URL:sourceURL options:nil error:&error];
    if (sourceMetadata == nil) {
        [Logger error:@"Failed to fetch metadata with error %@: %@", @(error.code), [error userInfo]];
        return NO;
    }
    
    NSManagedObjectModel *sourceModel = [NSManagedObjectModel mergedModelFromBundles:nil
                                                                    forStoreMetadata:sourceMetadata];
    
    if (sourceModel == nil) {
        [Logger error:@"Failed to create source model"];
        return NO;
    }
    
    NSManagedObjectModel *destinationModel = [self managedObjectModel];
    
    if ([destinationModel isConfiguration:nil compatibleWithStoreMetadata:sourceMetadata]) {
        [Logger error:@"No persistent store incompatilibilities detected, cancelling"];
        return YES;
    }
    
    [Logger debug:@"source model entities: %@", [[sourceModel entityVersionHashesByName] description]];
    [Logger debug:@"destination model entities: %@", [[destinationModel entityVersionHashesByName] description]];
    
    NSMappingModel *mappingModel;
    
    // try to get a mapping automatically first
    mappingModel = [NSMappingModel inferredMappingModelForSourceModel:sourceModel
                                                     destinationModel:destinationModel
                                                                error:&error];
    
    if (mappingModel == nil) {
        [Logger error:@"Could not create inferred mapping model: %@", [error userInfo]];
        // try again with xcmappingmodel files we created
        mappingModel = [NSMappingModel mappingModelFromBundles:nil
                                                forSourceModel:sourceModel
                                              destinationModel:destinationModel];
        
        if (mappingModel == nil) {
            [Logger error:@"Failed to create mapping model"];
            return NO;
        }
    }
    
    
    NSValue *classValue = [[NSPersistentStoreCoordinator registeredStoreTypes] objectForKey:NSSQLiteStoreType];
    Class sqliteStoreClass = (Class)[classValue pointerValue];
    Class sqliteStoreMigrationManagerClass = [sqliteStoreClass migrationManagerClass];
    
    NSMigrationManager *manager = [[sqliteStoreMigrationManagerClass alloc]
                                   initWithSourceModel:sourceModel destinationModel:destinationModel];
    
    if (![manager migrateStoreFromURL:sourceURL type:NSSQLiteStoreType options:nil withMappingModel:mappingModel
                     toDestinationURL:destURL destinationType:NSSQLiteStoreType destinationOptions:nil error:&error]) {
        [Logger error:@"Migration failed with error %@: %@",@(error.code), [error userInfo]];
        return NO;
    }
    
    if (![[NSFileManager defaultManager] removeItemAtPath:sourcePath error:&error]) {
        [Logger error:@"Failed to remove old store with error %@: %@", @(error.code), [error userInfo]];
    }
    
    [Logger debug:@"Migration complete!"];
    return YES;
}

- (BOOL)wipeData {
    NSError *error = nil;
    NSString *storePath = [self storeFileName];
#ifdef DEBUG
    NSString *backupPath = [storePath stringByAppendingString:@".bak"];
    
    if ([[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        [[NSFileManager defaultManager] removeItemAtPath:backupPath
                                                   error:NULL];
    }
    
    if (![[NSFileManager defaultManager] copyItemAtPath:storePath toPath:backupPath error:&error]) {
        [Logger error:@"Failed to copy old store, error %d: %@", (int)[error code], [error description]];
        for (NSError *detailedError in [[error userInfo] objectForKey:NSDetailedErrorsKey]) {
            [Logger error:@"%@", [detailedError userInfo]];
        }
        return NO;
    } else if (![[NSFileManager defaultManager] removeItemAtPath:storePath error:&error]) {
        [Logger error:@"Failed to remove old store with error %d: %@", (int)[error code], [error userInfo]];
        [Logger error:@"Old store is at %@", storePath];
        return NO;
    } else {
        [Logger debug:@"Old store is backed up at %@", backupPath];
    }
#else
    if (![[NSFileManager defaultManager] removeItemAtPath:storePath error:&error]) {
        [Logger error:@"Failed to remove old store with error %@: %@", @(error.code), [error userInfo]];
        return NO;
    }
#endif
    return YES;
}

- (BOOL)isExist {
    NSString *currentFileName = [self currentStoreFileName];
    return [[NSFileManager defaultManager] fileExistsAtPath:currentFileName];
}

#pragma mark - 删除
- (void)deleteObjects:(NSArray *)objects {
    for (NSManagedObject *object in objects) {
        [self.managedObjectContext deleteObject:object];
    }
}

- (void)deleteObject:(NSManagedObject *)object {
    [self.managedObjectContext deleteObject:object];
}

#pragma mark - 插入

- (id)insertNewObjectForEntityForName:(NSString *)entityName {
    return [NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:self.managedObjectContext];
}

- (id)insertNewObjectForEntityForName:(NSString *)entityName context:(NSManagedObjectContext *)aManagedObjectContext {
    NSEntityDescription *entityDescription = [[self.managedObjectModel entitiesByName] objectForKey:entityName];
    return [[NSManagedObject alloc] initWithEntity:entityDescription insertIntoManagedObjectContext:aManagedObjectContext];
}

- (id)insertNewObjectWithNoContextForEntity:(NSString *)entityName {
    return [self insertNewObjectForEntityForName:entityName context:nil];
}

#pragma mark - 查询
- (NSArray *)fetchDataForAttribute:(NSString *)attributeName {
    NSFetchRequest *request = [[NSFetchRequest alloc] init];    // make a request object
    NSEntityDescription *entity = [NSEntityDescription entityForName:attributeName inManagedObjectContext:self.managedObjectContext];    // tell the request what to look for
    [request setEntity:entity];
    
    NSError *error;
    NSArray *result = [self.managedObjectContext executeFetchRequest:request error:&error];
    // TODO: handle errors when Core Data calls fail
    
    return result;
}

- (NSArray *)fetchDataForAttribute:(NSString *)attributeName sortDescriptor:(NSSortDescriptor *)sortDescriptor {
    NSArray *result = nil;
    NSFetchRequest *request = [[NSFetchRequest alloc] init];    // make a request object
    [request setSortDescriptors:[NSArray arrayWithObject:sortDescriptor]];
    
    if (self.managedObjectContext) {
        NSEntityDescription *entity = [NSEntityDescription entityForName:attributeName inManagedObjectContext:self.managedObjectContext];    // tell the request what to look for
        [request setEntity:entity];
        
        NSError *error;
        result = [self.managedObjectContext executeFetchRequest:request error:&error];
    }
    return result;
}

- (void)clearDataForAttribute:(NSString *)attributeName {
    for (id object in [self fetchDataForAttribute:attributeName]) {
        [self deleteObject:(NSManagedObject *)object];
    }
    [self saveData];
}

- (id)objectsForEntity:(NSString *)entityName matchingPredicate:(NSPredicate *)predicate sortDescriptors:(NSArray *)sortDescriptors {
    NSEntityDescription *entity = [NSEntityDescription entityForName:entityName inManagedObjectContext:self.managedObjectContext];
    NSFetchRequest *request = [[NSFetchRequest alloc] init];
    [request setEntity:entity];
    if (predicate != nil) {
        [request setPredicate:predicate];
    }
    if (sortDescriptors) {
        [request setSortDescriptors:sortDescriptors];
    }
    
    NSError *error = nil;
    NSArray *objects;
    @try {
        objects = [self.managedObjectContext executeFetchRequest:request error:&error];
    }
    @catch (NSException *exception) {
        [Logger error:@"executeFetchRequest Exception"];
        objects = nil;
    }
    return objects;
}

- (id)objectsForEntity:(NSString *)entityName matchingPredicate:(NSPredicate *)predicate sortDescriptors:(NSArray *)sortDescriptors limit:(NSUInteger)limit{
    NSEntityDescription *entity = [NSEntityDescription entityForName:entityName inManagedObjectContext:self.managedObjectContext];
    NSFetchRequest *request = [[NSFetchRequest alloc] init];
    [request setEntity:entity];
    if (predicate != nil) {
        [request setPredicate:predicate];
    }
    if (sortDescriptors) {
        [request setSortDescriptors:sortDescriptors];
    }
    if(limit)
        [request setFetchLimit:limit];
    
    NSError *error = nil;
    NSArray *objects = [self.managedObjectContext executeFetchRequest:request error:&error];
    return objects;
}

- (id)objectsForEntity:(NSString *)entityName matchingPredicate:(NSPredicate *)predicate {
    return [self objectsForEntity:entityName matchingPredicate:predicate sortDescriptors:nil];
}

- (id)getObjectForEntity:(NSString *)entityName attribute:(NSString *)attributeName value:(id)value {
    NSString *predicateFormat = [attributeName stringByAppendingString:@" like %@"];
    NSPredicate *predicate = [NSPredicate predicateWithFormat:predicateFormat, value];
    NSArray *objects = [self objectsForEntity:entityName matchingPredicate:predicate];
    return ([objects count] > 0) ? [objects lastObject] : nil;
}

#pragma mark - 保存
- (void)saveData {
    NSError *error = nil;
    
    // fgx 2011-12-14 add {
    if ([self.managedObjectContext hasChanges]) {
        // } fgx 2011-12-14 add
        if (![self.managedObjectContext save:&error]) {
            [Logger error:@"Failed to save to data store: %@", [error localizedDescription]];
            NSArray* detailedErrors = [[error userInfo] objectForKey:NSDetailedErrorsKey];
            if(detailedErrors != nil && [detailedErrors count] > 0) {
                for(NSError* detailedError in detailedErrors) {
                    [Logger error:@"  DetailedError: %@", [detailedError userInfo]];
                }
            }
            else [Logger error:@"%@", [error userInfo]];
            
        } else {
            [Logger debug:@"数据保存成功"];
        }
    }
}

- (void)saveDataWithTemporaryMergePolicy:(id)temporaryMergePolicy {
    NSManagedObjectContext *context = self.managedObjectContext;
    id originalMergePolicy = [context mergePolicy];
    [context setMergePolicy:NSOverwriteMergePolicy];
    [self saveData];
    [context setMergePolicy:originalMergePolicy];
}

- (void)mergeOnMainThread:(NSNotification *)aNotification {
    [[self managedObjectContext] mergeChangesFromContextDidSaveNotification:aNotification];
}

- (void)mergeContextChangesForNotification:(NSNotification *)aNotification {
    [self performSelectorOnMainThread:@selector(mergeOnMainThread:) withObject:aNotification waitUntilDone:YES];
}

@end
